#' Parse Chats
#'
#' This function parses a ReChat csv export into an R list.
#' @param file Path to csv file.
#' @keywords parse
#' @export
#' @examples
#' parseChat()

parseChat <- function(file) {
  raw_chat_data <- readr::read_lines(file)
  tops <- which(stringr::str_detect(raw_chat_data, pattern = "Room Id:"))
  bottoms <- which(raw_chat_data=="----------------------------------")
  chats_list <- list()
  for (i in 1:length(tops)){
    thischat <- raw_chat_data[tops[i]:bottoms[i]]
    thischatlist <- list()
    #room id
    thischatlist$room_id <- gsub(" ", "", x = stringr::str_split(thischat[1], ",", simplify = T)[2], fixed = T)
    #started at
    thischatlist$started_at <- lubridate::parse_date_time(x = stringr::str_replace_all(stringr::str_remove_all(stringr::str_remove(thischat[2], pattern = "Started At:, "), pattern = ","), pattern = "/", replacement = "-"), orders = "mdYHMS", tz = "America/New_York")
    #participant data
    thischatlist$participants <- readr::read_delim(I(thischat[(which(thischat == "Participants") + 1):(which(thischat == "Messages") - 2)]), delim = ",", show_col_types = FALSE)
    #messages
    thischatlist$messages <- readr::read_delim(I(thischat[(which(thischat == "Messages") + 1):(which(thischat == "Poll Responses") - 2)]), delim = ",", show_col_types = FALSE)
    chats_list[[i]] <- thischatlist
  }
  for (i in 1:length(chats_list)){
    chats_list[[i]]$messages <- dplyr::left_join(chats_list[[i]]$messages, chats_list[[i]]$participants, by = c("participantCode" = "colorCode"))
  }
  return(chats_list)
}



#' Featurize Chats
#'
#' This function generates features to describe each message in chats, using any featurization_function the user passes, so long as the function returns a vector the same length as the number of messages in each chat.
#' @param chat_data A list of chat data generated from the parseChat function.
#' @param feature_name Optional name for the feature to be added to chat_data.  If not provided, the feature will be named after the featurization function.
#' @param featurization_function The function to be used to featurize each chat message.
#' @param ... Additional arguments to be passed to the featurization_function
#' @keywords featurize
#' @export
#' @examples
#' featurizeChat()

featurizeChat <- function(chat_data, feature_name = NA, featurization_function, ...){
  if (is.na(feature_name)) {feature_name <- paste0(enexpr(featurization_function))}
  for (i in 1:length(chat_data)){
    eval(parse(text=paste0("chat_data[[i]]$messages$",feature_name," <- ",enexpr(featurization_function),"(chat_data[[i]]$messages$message",...,")")))
  }
  return(chat_data)
}



#' Summarize Chat Features
#'
#' This function takes chat features generated by featurizeChat, summarizes them to the participant level, and adds this summary information to the survey_data dataframe.
#' @param survey_data A dataframe of survey responses, including a column named ego_code that contains the receipt code the respondent entered after completing their chat.
#' @param chat_data A list of chat data generated from the parseChat function.
#' @param chat_feature_name The name of the chat feature (added to chat_data using featurizeChat) to summarize.
#' @param summary_feature_name Optional name for the summary feature to be added to survey_data.  If not provided, a descriptive name will be automatically generated as paste0("ego_",enexpr(summary_function),"_",chat_feature_name)
#' @param summary_function A function, such as mean(), to use to summarize the message-level features of a chat to the participant-level.
#' @param ... Additional arguments to be passed to the summary_function.
#' @keywords summarize
#' @export
#' @examples
#' summarizeChat()

summarizeChat <- function(survey_data, chat_data, chat_feature_name, summary_feature_name = NA, summary_function, ...){
  if (is.na(summary_feature_name)) {summary_feature_name <- paste0("ego_",enexpr(summary_function),"_",chat_feature_name)}
  eval(parse(text=paste0("survey_data$",summary_feature_name," <- rep(NA, nrow(survey_data))")))
  for (i in 1:length(chat_data)){#for each element of the chat data list
    all_codes <- chat_data[[i]]$participants$receiptCode #get all receipt codes
    for (j in 1:length(all_codes)){
      eval(parse(text=paste0("unsummarized <- chat_data[[i]]$messages$",chat_feature_name,"[which(chat_data[[i]]$messages$receiptCode == all_codes[j])]")))
      eval(parse(text=paste0("survey_data$",summary_feature_name,"[which(survey_data$ego_code == all_codes[j])] <- summary_function(unsummarized, ...)")))
    }
  }
  return(survey_data)
}



#' Match Alters
#'
#' This function adds an alter_code field to the survey_data dataframe, containing the receipt code that identifies each participant's chat partner.  Note that this function is written for dyadic chats only, and that the survey_data dataframe must contain a column named ego_code that contains the confirmation code entered by the participant after their chat (confirmation codes are generated by ReChat and participants should be instructed to enter the generated code into a free-text field in the survey, to facilitate this matching procedure).
#' @param survey_data A dataframe of survey responses, including a column named ego_code that contains the receipt code the respondent entered after completing their chat.
#' @param chat_data A list of chat data generated from the parseChat function.
#' @keywords match
#' @export
#' @examples
#' matchAlters()

matchAlters <- function(survey_data, chat_data){
  survey_data$alter_code <- rep(NA, nrow(survey_data))
  survey_data$room_id <- rep(NA, nrow(survey_data))
  for (i in 1:length(chat_data)){#for each element of the chat data list
    all_codes <- chat_data[[i]]$participants$receiptCode #get all receipt codes
    for (j in 1:length(all_codes)){
      alter_codes <- all_codes[-j] #the code that isn't j is the alter code
      #if (length(alter_codes)>1) {survey_data$alter_code[which(survey_data$ego_code == all_codes[j])] <- list(alter_codes)}#this needs updating for the multiple-alter case
      survey_data$alter_code[which(survey_data$ego_code == all_codes[j])] <- (alter_codes)#save alter code as alter_code of row where ego_code is equal to the other code in all_codes
      survey_data$room_id[which(survey_data$ego_code == all_codes[j])] <- chat_data[[i]]$room_id#save the room id
      # survey_data$ego_mean_sentiment[which(survey_data$ego_code == all_codes[j])] <- chat_data[[i]]$messages %>% filter(receiptCode == all_codes[j]) %>% pull(sentiment) %>% mean(., na.rm = T) #mean sentiment -- do this in separate function
      # survey_data$ego_mean_mention_score[which(survey_data$ego_code == all_codes[j])] <- chat_data[[i]]$messages %>% filter(receiptCode == all_codes[j]) %>% pull(mention_score) %>% myMean(.) #mean mention score -- do this in separate function
    }
  }
  return(survey_data)
}



#' Get Alter Variables
#'
#' This function retrieves the values of each participant's partner's (specified) variables, and appends them to the survey_data dataframe as new columns named as paste0("alter_", gsub("ego_", "", var_name)).  Note that this function is written for dyadic chats only.
#' @param survey_data A dataframe of survey responses, including a column named ego_code that contains the receipt code the respondent entered after completing their chat.
#' @param var_names A vector of variable names, that are present in colnames(survey_data), for which each participant's alter's values are desired.
#' @keywords alter
#' @export
#' @examples
#' getAlterVars()

getAlterVars <- function(survey_data, var_names){
  for (var_name in var_names) {
    var_name_new <- paste0("alter_", gsub("ego_", "", var_name))
    eval(parse(text=paste0("survey_data$",var_name_new," <- rep(NA, nrow(survey_data))")))
  }
  for (i in 1:nrow(survey_data)) {
    if(!is.na(survey_data$alter_code[i])){
      if (any(survey_data$ego_code == survey_data$alter_code[i], na.rm = T)){
        for (var_name in var_names) {
          var_name_new <- paste0("alter_", gsub("ego_", "", var_name))
          eval(parse(text=paste0("survey_data$",var_name_new,"[i] <- survey_data$",var_name,"[which(survey_data$ego_code == survey_data$alter_code[i])]")))
        }
      }
    }
  }
  return(survey_data)
}


#' Print Chat
#'
#' This function exports a selected chat as a readable PDF file.
#' @param chat The chat to print, for example chat_data[[1]]
#' @param width Width of output file in pixels.
#' @param height Height of output file in pixels.
#' @param file File path to save export.
#' @param format File format for export.  Currently "pdf" and "png" are supported.
#' @keywords alter
#' @export
#' @examples
#' printChat()

printChat <- function(chat, width=500, height=500, file = "chat_export", format = "pdf"){
  messages <- chat$messages
  text = '<html class>'
  text = c(text, '<head>')
  text = c(text, '<script src="jquery-3.6.0/jquery.min.js"></script>')
  text = c(text, '<link href="shiny-css-1.7.4/shiny.min.css" rel="stylesheet">')
  #text = c(text, '<link href="shinyChatR.css" rel="stylesheet">')
  text = c(text, '</head>')
  text = c(text, '<style type="text/css">')
  text = c(text, read_lines(system.file("css", "myChat.css", package="rechat")))
  text = c(text, '</style>')

  #text = c(text, '')
  text = c(text, '<body>')
  text = c(text, '<div class="chatMessages" width="',width,'px" style="height:',height,'px">\n<div id="test2-chatbox" class="shiny-html-output shiny-bound-output" aria-live="polite">')
  for (i in 1:nrow(messages)){
    text = c(text, '<div class="chatMessage',dplyr::if_else(messages$participantCode[i]==messages$participantCode[1], true = " me", false = ""),'"><p>',messages$message[i],'</br><strong>',dplyr::if_else(messages$participantCode[i]==messages$participantCode[1], true = "user1", false = "user2"),'</strong>','</p></div>')
  }
  text = c(text,'</div>\n</div>')
  #cat(text, sep = "\n")
  #text = c(text, '')
  text = c(text, '</body>')
  text = c(text, '</html>')

  tmp_file <- tempfile(fileext = ".html")
  write(text, file = tmp_file)
  webshot(tmp_file, paste0(file, ".", format), vwidth = 400)
}
